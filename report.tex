\documentclass[11pt,a4paper,english]{paper} 
\usepackage{fontspec}
\usepackage[utf8]{inputenc}
\usepackage[margin=2cm]{geometry}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{bm}
\usepackage[usenames,dvipsnames]{color}
\usepackage{booktabs}
\usepackage{fancyhdr}
\usepackage[most]{tcolorbox}
\usepackage[authoryear]{natbib}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{eucal}
\usepackage[]{minted}
\usepackage{enumitem}
\usepackage{latexsym}
\usepackage{indentfirst}
\usepackage[english]{babel}
\usepackage[autostyle, english = american]{csquotes}
\usepackage{titlesec}

\titleformat*{\section}{\LARGE\bfseries}
\titleformat*{\subsection}{\Large\bfseries}
\titleformat*{\subsubsection}{\large}
\MakeOuterQuote{"}

\setmonofont[Scale=0.75]{Hack NF}

\def \courseNumber {CS3500}
\def \courseName {Operating Systems}
\def \assignmentName {System Calls (Part 2)}
\def \myName {Akilesh Kannan}
\def \rollNumber {EE18B122}

\pagestyle{fancy}
\fancyhf{}
\rhead{\assignmentName}
\lhead{\courseNumber: \courseName}
\cfoot{\thepage}

\linespread{1.2}

\renewcommand{\familydefault}{\sfdefault} %command to change font to sans-serif

\definecolor{blue(ryb)}{rgb}{0.01, 0.28, 1.0}
\definecolor{green(ryb)}{rgb}{0.28, 1.0, 0.01}
\definecolor{red(ryb)}{rgb}{1.0, 0.01, 0.28}
\definecolor{black(ryb)}{rgb}{0, 0, 0}
\definecolor{gray(ryb)}{rgb}{0.75, 0.75, 0.75}

\newenvironment{colorboxed}[4][gray]{
\begin{tcolorbox}[colback=#1!3!white,colframe=#1(ryb)!50!black,title=\textbf{#2: #3},#4]
}{
\end{tcolorbox}
}

\begin{document} 
\thispagestyle{empty}
\vspace{-4.5cm}

\hspace*{-\parindent}
\begin{minipage}{0.65\textwidth}
{\fontsize{22pt}{10pt}\selectfont\textbf{\assignmentName}}\\[1mm]
\Large
\textit{\courseNumber: \courseName}\\[5mm]
\Large \myName \\
\normalsize \rollNumber \\
\end{minipage}\hfill% push everything to the right
\raisebox{-13mm}{\includegraphics[scale=.28]{logo.pdf}}

\hrule \hrule
\medskip
\vspace{-0.2cm}

\section*{Problem 1}
\begin{colorboxed}{Code}{\texttt{kernel/sysproc.c::\textit{sys\_echo\_simple()}}}{unbreakable}
    \inputminted[baselinestretch=0.85,firstline=108,lastline=117,breaklines]{c}{kernel/sysproc.c}
\end{colorboxed}
\subsection*{Approach}
\begin{itemize}[noitemsep, nolistsep]
    \item Get argument passed to user program (\texttt{user/test\_program\_1.c}) using \texttt{argstr()} as a \textit{string}.
    \item Use \texttt{printf()} to print the argument to \texttt{STDOUT}.
\end{itemize}
\section*{Problem 2}
\begin{colorboxed}{Code}{\texttt{kernel/sysproc.c::\textit{sys\_echo\_kernel()}}}{breakable}
    \inputminted[baselinestretch=0.85,firstline=119,lastline=143,breaklines]{c}{kernel/sysproc.c}
\end{colorboxed}
\subsection*{Approach}
\begin{itemize}[noitemsep, nolistsep]
    \item Get address of argument (\texttt{arg\_addr}) to print, from location \texttt{argv\_base\_addr} using \texttt{argaddr()}.
    \item Get string argument located at \texttt{arg\_addr} using \texttt{fetchstr()}. \textit{Note that \texttt{fetchstr()} requires the length of the string also to be passed. This is done with help of a fixed maximum length of \texttt{MAXARGLENGTH} }.
    \item Use \texttt{printf()} to print the argument to \texttt{STDOUT}.
    \item Increment \texttt{argv\_base\_addr} by \texttt{sizeof(char*)} and go to next argument.
    \item Repeat for \texttt{argc}$-1$ number of times (as argc includes program name also in count.)
\end{itemize}
\section*{Problem 3 and 4}
\begin{colorboxed}{Code}{\texttt{kernel/sysproc.c::\textit{sys\_trace()}}}{unbreakable}
    \inputminted[baselinestretch=0.85,firstline=145,lastline=155,breaklines]{c}{kernel/sysproc.c}
\end{colorboxed}
\begin{colorboxed}{Code}{\texttt{kernel/syscall.c::\textit{syscall()}}}{unbreakable}
    \inputminted[baselinestretch=0.85,firstline=156,lastline=175,breaklines]{c}{kernel/syscall.c}
\end{colorboxed}
\subsection*{Approach}
\begin{itemize}[noitemsep, nolistsep]
    \item Get type of syscall from process's \texttt{a7} register.
    \item Check if the process's trace mask is enabled for the syscall and print \texttt{PID} and \texttt{name} for the syscall using \texttt{pid} and \texttt{name} fields in \texttt{proc} structure.
    \item Call appropriate syscall routine.
    \item Get arguments of the syscall using appropriate helper functions like \texttt{argint}, \texttt{argaddr} and \texttt{argstr} and print them if process's trace mask has current syscall enabled. \textit{This is done inside each syscall routine}.
    \item Return from syscall routine and extract the \texttt{return value} from the process's \texttt{a0} register. Print if necessary.
\end{itemize}
\section*{Problem 5}
\begin{colorboxed}{Code}{\texttt{kernel/sysproc.c::\textit{sys\_get\_process\_info()}}}{unbreakable}
    \inputminted[baselinestretch=0.85,firstline=157,breaklines]{c}{kernel/sysproc.c}
\end{colorboxed}
\begin{colorboxed}{Code}{\texttt{user/test\_program\_5.c::\textit{main()}}}{unbreakable}
    \inputminted[baselinestretch=0.85,firstline=1,lastline=19,breaklines]{c}{user/test_program_5.c}
\end{colorboxed}
\subsection*{Approach}
\begin{itemize}[noitemsep, nolistsep]
    \item Initialise a variable of type \texttt{struct processinfo} in the user program.
    \item Call the system call, with the address of this variable as it's argument.
    \item Extract \texttt{PID}, \texttt{name} and \texttt{size} of process from the \texttt{pid}, \texttt{name} and \texttt{sz} fields of the \texttt{proc} structure respectively and use them to fill a temporary \texttt{struct processinfo}.
    \item Using \texttt{copyout}, we transfer \texttt{sizeof(struct processinfo)} bytes from the kernel space to the user space. The data will be copied to a location with a base address of \texttt{destination} (address of \texttt{struct processinfo} in user space).
\end{itemize}

%%Beginning References. Don't add any text beyond this.
%%------------------------------------------

%\newpage %sending References to the last page

%\bibliography{paper}
%\bibliographystyle{apalike}
\end{document}
